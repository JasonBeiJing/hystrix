Hystrix 是什么
	- 在一个分布式系统里，许多依赖不可避免的会调用失败，比如超时、异常等，如何能够保证在一个依赖出问题的情况下，不会导致整体服务失败，这个就是Hystrix需要做的事情。Hystrix提供了熔断、隔离、降级、缓存、请求合并、监控等功能，能够在一个、或多个依赖同时出现问题时保证系统依然可用,从而使复杂的分布式系统更具弹性.
	- 例如，对于依赖30个服务的应用程序，每个服务的正常运行时间为99.99%，对于单个服务来说，99.99%的可用率是完美的。对于整个系统的可用率来说，可用率为99.99％^30＝99.7%，不可用率为0.3%，那么10亿次请求中就用3000000失败，实际情况有可能更糟糕。
	- 大多数人在使用Tomcat时，多个HTTP服务会共享一个线程池，假设其中一个HTTP服务访问的数据库响应非常慢，这将造成服务响应时间延迟增加，大多数线程阻塞等待数据响应返回，导致整个Tomcat线程池都被该服务占用，甚至拖垮整个Tomcat.
	因此，如果我们能把不同HTTP服务隔离到不同的线程池，则某个HTTP服务的线程池满了也不会对其他服务造成灾难性故障。这就需要线程隔离或者信号量隔离来实现了。
	- 使用线程隔离或信号隔离的目的是为不同的服务分配一定的资源，当自己的资源用完，直接返回失败而不是占用别人的资源。
	比如“HTTP服务1”和“HTTP服务2”要分别访问远程的“分布式服务A”和“分布式服务B”，假设它们共享线程池，那么其中一个服务在出现问题时也会影响到另一个服务，因此，我们需要进行访问隔离，可以通过Hystrix的线程池隔离或信号量隔离来实现。
	- Hystrix是一个能够为延迟和故障提供更强大的容错能力的库，通过隔离访问远程系统、服务和第三方库的节点，阻止级联故障，从而使复杂的分布式系统更具弹性。
Hystrix 解决了什么问题
	- 在通过第三方客户端访问依赖服务出现高延迟或者失败时，为系统提供保护和控制
	- 在分布式系统中防止级联失败
		比如 A-->B-->C-->D, ABC都没问题，但是D出现了网络延迟，那么整个用户请求就处于阻塞状态。如果并发量较高，很有可能因为D服务的网络延迟，在几秒钟内就使整个服务（ABC）处于线程负载饱和状态，最终导致线程资源消耗殆尽，进而导致整个系统崩溃，即雪崩效应。
	- 快速失败（Fail fast）同时能快速恢复
	- 提供失败回退（Fallback）和优雅的服务降级机制
	- 提供近实时的监控、报警和运维控制手段
Hystrix 的工作原理
	- 舱壁模式
		- 比如，货船为了进行防止漏水和火灾的扩散,会将货仓分隔为多个，当发生灾害时，将所在货仓进行隔离就可以降低整艘船的风险
	- 隔离策略 ==>［线程池隔离 + 信号量隔离]
		- 分布式系统中，一个服务会依赖许多其他的服务，并且这些服务都不可避免地有失效的可能。如果一个应用没有与依赖服务的失效隔离开来，那么它将有可能因为依赖服务的失效而崩溃
		-Hystrix将舱壁模式运用到了服务调用者上。为每一个依赖服务维护一个线程池（或者信号量），当线程池占满，该依赖服务将会被立即拒绝而不是排队等待
		- 每个依赖服务都被隔离开来，Hystrix会严格控制其对资源的占用，并在任何失效发生时（断路器打开），执行失败回退逻辑。 
	- 观察者模式
		- Hystrix通过观察者模式对服务进行状态监听
		- 每个任务都包含有一个对应的Metrics，所有Metrics都由一个ConcurrentHashMap来进行维护，Key是CommandKey.name() 
		- 在任务的不同阶段会往Metrics中写入不同的信息，Metrics会对统计到的历史信息进行统计汇总，供熔断器以及Dashboard监控时使用
	－ 熔断机制
		- 熔断是参考电路而产生的一种保护性机制，即系统中如果存在某个服务失败率过高时，将开启熔断器，对于后续的调用，不再继续请求服务，而是进行Fallback操作
			*: 比如，家里使用的插座，一个烧了就切断一个，而不会引起整个家用电路烧毁
		- 熔断所依靠的数据即是Metrics中的HealthCount所统计的错误率
			*: 每个熔断器默认维护10个bucket,每秒一个bucket,每个bucket记录成功、失败、拒绝等状态，默认错误超过50%且10秒内超过20个请求进行中断拦截.
Hystrix设计原则
	- 防止单个依赖耗尽容器（例如 Tomcat）内所有用户线程
	- 降低系统负载，对无法及时处理的请求快速失败（fail fast）而不是排队
	- 提供失败回退，以在必要时让失效对用户透明化
	- 使用隔离机制（例如『舱壁』/『泳道』模式，熔断器模式等）降低依赖服务对整个系统的影响
	- 能保护应用不受依赖服务的整个执行过程中失败的影响，而不仅仅是网络请求
//******************************************************************************************************************************//
线程池隔离的优点:
	[1]:应用程序会被完全保护起来，即使依赖的一个服务的线程池满了，也不会影响到应用程序的其他部分。
	[2]:我们给应用程序引入一个新的风险较低的客户端lib的时候，如果发生问题，也是在本lib中，并不会影响到其他内容，因此我们可以大胆的引入新lib库。
	[3]:当依赖的一个失败的服务恢复正常时，应用程序会立即恢复正常的性能。
	[4]:如果我们的应用程序一些参数配置错误了，线程池的运行状况将会很快显示出来，比如延迟、超时、拒绝等。同时可以通过动态属性实时执行来处理纠正错误的参数配置。
	[5]:如果服务的性能有变化，从而需要调整，比如增加或者减少超时时间，更改重试次数，就可以通过线程池指标动态属性修改，而且不会影响到其他调用请求。
	[6]:除了隔离优势外，hystrix拥有专门的线程池可提供内置的并发功能，使得可以在同步调用之上构建异步的外观模式，这样就可以很方便的做异步编程（Hystrix引入了Rxjava异步框架）。
	尽管线程池提供了线程隔离，我们的客户端底层代码也必须要有超时设置，不能无限制的阻塞以致线程池一直饱和。

线程池隔离的缺点:
	[1]:线程池的主要缺点就是它增加了计算的开销，每个业务请求（被包装成命令）在执行的时候，会涉及到请求排队，调度和上下文切换。不过Netflix公司内部认为线程隔离开销足够小，不会产生重大的成本或性能的影响。
		The Netflix API processes 10+ billion Hystrix Command executions per day using thread isolation. Each API instance has 40+ thread-pools with 5–20 threads in each (most are set to 10).
		Netflix API每天使用线程隔离处理10亿次Hystrix Command执行。 每个API实例都有40多个线程池，每个线程池中有5-20个线程（大多数设置为10个）。

当我们依赖的服务是极低延迟的，比如访问内存缓存，就没有必要使用线程池的方式，那样的话开销得不偿失，而是推荐使用信号量这种方式。

